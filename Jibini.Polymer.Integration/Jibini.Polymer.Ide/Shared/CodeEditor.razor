@inject IJSRuntime js

<KeepWithin>
    <div class="code-editor" @ref="@editorPane"
        tabindex="1" contenteditable="true">

        @{
            var cIndex = 0;
            Func<string, RenderFragment> stringContent = (s) =>
                @<text>
                    @foreach (var c in s)
                    {
                        var i = cIndex++;
                        <span @onclick="@(async () => await MoveCursorToAsync(i))">@c</span>
                    }
                </text>;

            RenderFragment dropdownContent =
                @<text>
                    <div class="cursor-content @(CursorMenuShown ? "d-block" : "d-none")">
                        
                        @* PLACEHOLDER "AUTO-COMPLETE" ITEMS *@
                        @foreach (var item in RawContent.Split(" "))
                        {
                            <div>@item</div>
                        }

                    </div>
                </text>;
        }

        <pre>
            @(stringContent(RawContent.Substring(0, CursorPosition))
            
            )<div class="cursor" contenteditable="false">
                <KeepIn>@dropdownContent</KeepIn>
            </div>@(

            stringContent(RawContent.Substring(CursorPosition)))
        </pre>

    </div>
</KeepWithin>

@code {
    [Parameter]
    public string RawContent { get; set; } = "";

    [Parameter]
    public EventCallback<string> RawContentChanged { get; set; }

    [Parameter]
    public int CursorPosition { get; set; }

    [Parameter]
    public EventCallback<int> CursorPositionChanged { get; set; }

    [Parameter]
    public bool CursorMenuShown { get; set; }

    [Parameter]
    public EventCallback<bool> CursorMenuShownChanged { get; set; }

    private readonly Guid guid = Guid.NewGuid();
    private IJSObjectReference? script;
    private ElementReference? editorPane;

    override protected async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        script ??= await js.InvokeAsync<IJSObjectReference>("import", "./js/CodeEditor.js");
        if (firstRender)
        {
            await script.InvokeVoidAsync("bindEditorEvents", DotNetObjectReference.Create(this), editorPane);
        }
    }

    [JSInvokable]
    public async Task EnterContentAsync(string content)
    {
        var oldContentLength = RawContent.Length;

        RawContent = RawContent.Insert(CursorPosition, content);
        await RawContentChanged.InvokeAsync(RawContent);

        CursorPosition += RawContent.Length - oldContentLength;
        await CursorPositionChanged.InvokeAsync(CursorPosition);

        StateHasChanged();
    }

    [JSInvokable]
    public async Task OnKeyPressedAsync(string key)
    {
        var oldContentLength = RawContent.Length;
        switch (key)
        {
            case "Alt":
            case "CapsLock":
            // Control is filtered in JS module
            case "Control":
            case "Delete":
            case "End":
            case "F1":
            case "F2":
            case "F3":
            case "F4":
            case "F5":
            case "F6":
            case "F7":
            case "F8":
            case "F9":
            case "F10":
            case "F11":
            case "F12":
            case "Home":
            case "Insert":
            case "Meta":
            case "NumLock":
            case "PageDown":
            case "PageUp":
            case "Pause":
            case "Shift":
                break;

            case "Backspace":
                if (CursorPosition > 0)
                {
                    RawContent = RawContent.Remove(CursorPosition - 1, 1);
                }
                break;
            case "Enter":
                RawContent = RawContent.Insert(CursorPosition, "\n");
                break;
            case "Escape":
                CursorMenuShown = false;
                await CursorMenuShownChanged.InvokeAsync(CursorMenuShown);
                break;
            case "Tab":
                RawContent = RawContent.Insert(CursorPosition, "    ");
                break;

            case "ArrowLeft":
                CursorPosition = Math.Max(0, CursorPosition - 1);
                break;
            case "ArrowUp":
                break;
            case "ArrowRight":
                CursorPosition = Math.Min(RawContent.Length, CursorPosition + 1);
                break;
            case "ArrowDown":
                break;

            default:
                RawContent = RawContent.Insert(CursorPosition, key);
                CursorMenuShown = true;
                await CursorMenuShownChanged.InvokeAsync(CursorMenuShown);
                break;
        }
        await RawContentChanged.InvokeAsync(RawContent);

        CursorPosition += RawContent.Length - oldContentLength;
        await CursorPositionChanged.InvokeAsync(CursorPosition);

        StateHasChanged();
    }

    private async Task MoveCursorToAsync(int charIndex)
    {
        CursorPosition = charIndex;
        await CursorPositionChanged.InvokeAsync(CursorPosition);
    }
}
